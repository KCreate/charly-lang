export = {

  # Iterates over all elements inside an array
  # callback receives the element and the index
  func each(callback) {
    let i = 0
    let count = self.length()

    while (i < count) {
      callback(self[i], i)
      i += 1
    }

    self
  }

  # Iterates over all elements inside an array
  # *callback* receives the element and the index
  # Each item in the array will be replaced with the result
  # of the callback
  func map(callback) {
    self.each(func(v, i) {
      self[i] = callback(v, i)
    })
  }

  # Returns a new array whichs contains all
  # elements for which the passed block returned a truthy value
  func filter(callback) {
    let new = []
    self.each(func(e, i) {
      if (callback(e, i)) {
        new.push(e)
      }
    })
    new
  }

  # Return a reversed version of this string
  func reverse() {
    let new = []
    self.each(func(e) {
      new.unshift(e)
    })
    new
  }

  # Returns a copied version of this array
  # Remember that objects and arrays are always passed by reference
  func copy() {
    self.map(func(e) { e })
  }

  # Clears the current array
  # This modified the array in place
  func clear() {
    while (self.length() > 0) {
      self.delete(0)
    }
    self
  }

  func index_of(element) {
    let index = -1
    let i = 0

    let length = self.length()
    let found = false

    while (i < length) {
      if (!found) {
        if (self[i].type() == element.type()) {
          if (self[i] == element) {
            index = i
            found = true
            i = length
          }
        }
      }
      i += 1
    }

    index
  }

  func sort(sort_function) {
    let done = false
    let sorted = self.copy()

    # some temporary variables
    # initialized here to save memory
    let next
    let tmp

    while (!done) {
      done = true
      sorted.each(func(left, i) {
        if (i ! self.length() - 1) {
          next = self[i + 1]

          # Run the user specified sorting function
          if (sort_function(left, next)) {
            tmp = next
            sorted[i + 1] = left
            sorted[i] = tmp
            done = false
          }
        }
      })
    }

    sorted
  }

  # Converts all elements inside this array to strings
  # This modifies the array in place
  func all_to_s() {
    let new = Array.of_size(self.length(), null)
    self.each(func(v, i) {
      new[i] = v.to_s()
    })
    new
  }

  # Return the first element in this array
  func first() {
    self[0]
  }

  # Returns true if the array is empty
  func empty() {
    self.length() == 0
  }

  # Return the last element in this array
  func last() {
    self[self.length() - 1]
  }

  # Append to the end of the array
  func push(element) {
    call_internal("array_insert", self, self.length(), element)
  }

  # Append to the beginning of the array
  func unshift(element) {
    call_internal("array_insert", self, 0, element)
  }

  # Insert an element at a given index
  #
  # If the index if smaller than 0
  # it will be inserted at the beginning
  # 
  # If the index is bigger than the size of the array it will be inserted at the end
  func insert(index, element) {
    call_internal("array_insert", self, index, element)
  }

  # Delete the element at a given index
  #
  # If the index is smaller than 0, the first element will be deleted
  # If the index is bigger than the size of the array, the last item will be deleted
  func delete(index) {
    call_internal("array_delete", self, index)
  }

  # Return a new array by concatening self and element
  # If element is an array, they will be merged
  func __plus(element) {
    if (element.type() ! "Array") {

      # Create a new array containing self.length + 1 items
      let new_array = Array.of_size(self.length() + 1, null)
      self.each(func(v, i) {
        new_array[i] = v
      })
      new_array[new_array.length() - 1] = element
      new_array
    } else {

      # Create an array with the size of the two arrays combined
      let new_array = Array.of_size(self.length() + element.length(), null)

      # Copy the values
      self.each(func(v, i) {
        new_array[i] = v
      })

      element.each(func(v, i) {
        new_array[i + self.length()] = v
      })

      new_array
    }
  }

  # Returns a recursively flattened version of this array
  func flatten() {
    let new = []

    self.each(func(e) {
      if (e.type() == "Array") {
        e.flatten().each(func(e) {
          new.push(e)
        })
      } else {
        new.push(e)
      }
    })

    new
  }

  # Join the elements of the array together
  func join(separator) {
    let string = ""
    let count = self.length()

    self.each(func(e, index) {
      string += e.to_s()

      # Unless were at the last element, append the separator
      if (index < count - 1) {
        string += separator.to_s()
      }
    })

    string
  }

  # Compare an array to something else
  func __equal(other) {

    # Check the type first off
    if (other.type() ! self.type()) {
      false
    } else if (other.type() == "Boolean") {
      other
    } else {

      # Check the length
      if (other.length() ! self.length()) {
        false
      } else {

        # Iterate over the contents
        let equal = true
        other.each(func(e, i) {
          if (equal) {
            equal = e == self[i]
          }
        })
        equal
      }
    }
  }
}
