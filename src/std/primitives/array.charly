const array_insert = __internal__method("array_insert")
const array_delete = __internal__method("array_delete")
const array_of_size = __internal__method("array_of_size")

export = primitive class Array {

  # Calls the callback with each element and the index
  func each(callback) {
    let i = 0
    while i < @length() {
      callback(self[i], i)
      i += 1
    }
    self
  }

  # Calls the callback with each element and the index
  # The return value is an array of return values from the callback
  func map(callback) {
    let new = []
    @each(func(e, i) {
      new.push(callback(e, i))
    })
    new
  }

  # Returns a new array whichs contains all
  # elements for which the passed block returned a truthy value
  func filter(callback) {
    let new = []
    @each(func(e, i) {
      if (callback(e, i)) {
        new.push(e)
      }
    })
    new
  }

  # Returns true if this array is empty
  func empty() {
    @length() == 0
  }

  # Returns an array where all children are turned into strings
  func all_to_s() {
    @map(func(e) {
      e.to_s()
    })
  }

  # Append an item to the end of this array
  func push(item) {
    array_insert(self, item, @length())
    self
  }

  # Append an item to the beginning of this array
  func unshift(item) {
    array_insert(self, item, 0)
    self
  }

  # Inserts *item* at *index*
  func insert(item, index) {
    array_insert(self, item, index)
    self
  }

  # Deletes the item at *index*
  func delete(index) {
    array_delete(self, index)
    self
  }

  # Returns the string representation of this array
  func to_s() {
    let io = "["
    let amount = @length()
    @each(func(e, i) {
      io += e.to_s()

      if i ! amount - 1 {
        io += ", "
      }
    })
    io += "]"
    io
  }

  # Return a new array of a given size
  func of_size(size) {
    array_of_size(size)
  }

  # Return the first element of this array
  func first() {
    self[0]
  }

  # Return the last element of this array
  func last() {
    self[@length() - 1]
  }

  # Return a reversed version of this array
  func reverse() {
    let new = []
    @each(func(e) {
      new.unshift(e)
    })
    new
  }

  # Returns a recursively flattened version of this array
  func flatten() {
    let new = []

    @each(func(e) {
      if (e.typeof() == "Array") {
        e.flatten().each(func(e) {
          new.push(e)
        })
      } else {
        new.push(e)
      }
    })

    new
  }

  # Returns the index of *element* if found
  # Returns -1 of not found
  func index_of(element) {
    let index = -1
    let i = 0

    let length = self.length()
    let found = false

    while (i < length) {
      if (!found) {
        if ((self[i].typeof() == element.typeof()) && (self[i] == element)) {
          index = i
          found = true
          i = length
        }
      }
      i += 1
    }

    index
  }

  # Join the elements of the array together
  func join(separator) {
    let string = ""
    let count = @length()

    @each(func(e, index) {
      string += e.to_s()

      # Unless were at the last element, append the separator
      if (index < count - 1) {
        string += separator.to_s()
      }
    })

    string
  }

  func range(start, end) {

    # Switch params if start is bigger
    if start > end {
      let tmp = end
      end = start
      start = tmp
    }

    # Create the new array
    const new = []
    const length = @length()
    start.upto(end, func(n) {
      if ((n >= -1) && n < length) {
        new.push(self[n])
      }
    })
    new
  }
}
