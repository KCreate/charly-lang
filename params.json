{
  "name": "Charly-lang",
  "tagline": "🐈 The Charly Interpreter",
  "body": "# Charly Language Guide\r\n## Version 0.0.1\r\n\r\nYour syntax files need to be encoded in UTF-8.\r\n\r\n## Comments\r\nComments start with the sharp `#` character. Only one-line comments are currently supported.\r\n\r\n```javascript\r\n# This is a comment\r\n```\r\n\r\n## Variables\r\n\r\nVariables are defined via the `let` keyword. If you try to access a variable that wasn't initialized before, a runtime exception is thrown.\r\n\r\n```javascript\r\nlet myVar = 25\r\nlet myOtherVariable = 50\r\n\r\nmyVar + myOtherVariable # => 75\r\n```\r\n\r\n## Constants\r\n\r\nConstants are declared the same way as variables. They can't be changed, hence the name constant. You need to initialize them in the declaration.\r\n\r\n```javascript\r\nconst myconst # => syntax error\r\nconst myOtherConst = 25\r\nmyOtherConst = 30 # => runtime exception\r\n```\r\n\r\n## Literals\r\n\r\nCharly has a total of 10 primitive types. Not all can be constructed directly. For example the `TInternalFunction` can only be gathered from a call to `__internal__method`\r\n\r\n| Literal                 | Type     |\r\n|-------------------------|----------|\r\n| 25                      | Numeric  |\r\n| 25.5                    | Numeric  |\r\n| \"Charly\"                | String   |\r\n| [1, 2, 3]               | Array    |\r\n| null                    | Null     |\r\n| NAN                     | Numeric  |\r\n| false                   | Boolean  |\r\n| true                    | Boolean  |\r\n| class Box {}            | Class    |\r\n| func() {}               | Function |\r\n| ->() {}                 | Function |\r\n| { let name = \"charly\" } | Object   |\r\n\r\n### Null\r\nThe `Null` type can be compared to `undefined` in javascript or `nil` in some other languages.\r\n\r\n```javascript\r\nnull\r\n```\r\n\r\n### Boolean\r\nA `Boolean` only has two different values: `true` and `false`.\r\n\r\n```javascript\r\ntrue\r\nfalse\r\n```\r\n\r\n### Numeric\r\nAll Numeric types inside Charly are Crystal's native `Float64` type.\r\n\r\nNumeric literals, just like any other expression in the language, can be prefixed with `-` to negate them.\r\n\r\nUnderscores can be used to make some numbers more readable:\r\n\r\n```javascript\r\n1_000_000 # better than 1000000\r\n```\r\n\r\nFloats are created using the `.` character.\r\n\r\n```javascript\r\n123_456.456_789\r\n```\r\n\r\nA Numeric will silently overflow if you pass the lower or upper limit of `Float64`. The following REPL session elaborates this:\r\n\r\n![Numeric literal overflowing](images/overflow.png)\r\n\r\nOperations such as `1 / 0` will result in the `NAN` value.\r\n\r\n### String\r\nA String represents an immutable sequence of UTF-8 characters.\r\n\r\nIt uses Crystal's native `String` type underneath.\r\n\r\nYou can create it using `\"` characters.\r\n\r\n```javascript\r\n\"hello world\"\r\n```\r\n\r\nA backslash can be used to denote various special characters inside the string:\r\n\r\n```javascript\r\n\"\\\"\" # double quote\r\n\"\\\\\" # backslash\r\n\"\\e\" # escape\r\n\"\\f\" # form feed\r\n\"\\n\" # newline\r\n\"\\r\" # carriage return\r\n\"\\t\" # tab\r\n\"\\v\" # vertical tab\r\n```\r\n\r\nA string can span multiple lines:\r\n\r\n```javascript\r\n\"hello\r\n      word\" # same as \"hello\\n     world\"\r\n```\r\n\r\n### Array\r\nAn Array is a resizeable list of items of any type. It is typically created with an array literal:\r\n\r\n```javascript\r\n[1, 2, 3]\r\n[1, \"hello world\", [\"whats up\"]]\r\n```\r\n\r\nYou can add new items to an array using the push method:\r\n\r\n```javascript\r\nlet nums = []\r\nnums.push(0)\r\nnums.push(1)\r\nnums.push(2)\r\n\r\nnums # => [0, 1, 2]\r\n```\r\n\r\nYou can concat two arrays together via the `+` operator:\r\n\r\n```javascript\r\n[1, 2] + [3, 4] # => [1, 2, 3, 4]\r\n```\r\n\r\nYou can compare two arrays using the `==` operator:\r\n\r\n```javascript\r\n[1, 2, 3, 4] == [1, 2, 3, 4] # => true\r\n[1, 2] == [3, 4] # => false\r\n```\r\n\r\n### Objects\r\n\r\nCharly doesn't have special syntax to create objects. Instead it uses something we call `Containers`.\r\n\r\nA `Container` is basically the scope of a block turned into an Object:\r\n\r\n```javascript\r\nlet Box = {\r\n  let name = \"charly\"\r\n  let age = 200\r\n}\r\n\r\nBox.name # => \"charly\"\r\nBox.age # => 200\r\n```\r\n\r\nThis can be compared to the javascript equivalent of using `new Function()`:\r\n\r\n```javascript\r\nlet Box = (new function() {\r\n  this.name = \"charly\"\r\n  this.age = 200\r\n})\r\n\r\nBox.name // \"charly\"\r\nBox.age // 200\r\n```\r\n\r\nYou can access properties of objects via `[]`:\r\n\r\n```javascript\r\nlet Box = {\r\n  let name = \"mybox\"\r\n}\r\n\r\nBox[\"name\"] # => \"mybox\"\r\n```\r\n\r\n### Functions\r\n\r\nYou can define a new function like this:\r\n\r\n```javascript\r\nfunc foo() {\r\n  return \"hello world\"\r\n}\r\n```\r\n\r\nWhen written inside a block as a top-level-expression, it is automatically rewritten to the following:\r\n\r\n```javascript\r\nlet foo = func() {\r\n  return \"hello world\"\r\n}\r\n```\r\n\r\nThe last expression inside a function is used as it's return value\r\n\r\n```javascript\r\nfunc foo() {\r\n  25\r\n}\r\n\r\nfoo() # => 25\r\n```\r\n\r\nYou can also do explicit returns\r\n\r\n```javascript\r\nfunc foo() {\r\n  if true {\r\n    return true\r\n  }\r\n\r\n  return false\r\n}\r\n\r\nfoo() # => true\r\n```\r\n\r\nIf you only need the function literal, you can use anonymous function literals:\r\n\r\n```javascript\r\nfunc foo(callback) {\r\n  callback(42)\r\n}\r\n\r\nfoo(func(arg) {\r\n  print(arg) # => 42\r\n})\r\n```\r\n\r\nThere is also the lambda syntax, which goes like this:\r\n\r\n```javascript\r\n[1, 2, 3].map(->(num) {\r\n  print(num)\r\n})\r\n\r\n[1, 2, 3].map(->(num) print(num))\r\n```\r\n\r\nOf course you could also pass the print method directly, this would however result in the following:\r\n\r\n```javascript\r\n[1, 2, 3].map(print)\r\n\r\n# 1\r\n# 0\r\n# 3\r\n# 2\r\n# 1\r\n# 3\r\n# 3\r\n# 2\r\n# 3\r\n```\r\n\r\nBecause `Array#map` passes the value, index and size of the array to the callback, print will write all these values to the console.\r\n\r\nWhen you write a lambda function without parenthesis or curly braces, it will wrap the expression inside a block.\r\n\r\nThe following:\r\n\r\n```javascript\r\nfoo(->25)\r\n```\r\n\r\nbecomes:\r\n\r\n```javascript\r\nfoo(->{ 25 })\r\n```\r\n\r\nwhich in turn get's converted to:\r\n\r\n```javascript\r\nfoo(func() {\r\n  return 25\r\n})\r\n```\r\n\r\n### Classes\r\n\r\nClasses in Charly can inherit from multiple other classes.\r\n\r\nThey can have instance methods and properties and also static methods and properties.\r\n\r\nBelow is an example of a simple `Person` class.\r\n\r\n```javascript\r\nclass Person {\r\n  property name\r\n  property age\r\n  property height\r\n\r\n  func constructor(name, age, height) {\r\n    @name = name\r\n    @age = age\r\n    @height = height\r\n  }\r\n\r\n  func greet() {\r\n    print(\"My name is \" + @name)\r\n    print(\"I am \" + @age + \" years old\")\r\n    print(\"I am \" + @height + \" cm tall\")\r\n  }\r\n}\r\n\r\nlet John = Person(\"John\", 21, 1.85)\r\nJohn.greet()\r\n\r\n# Will print\r\n#\r\n# My name is John\r\n# I am 21 years old\r\n# I am 1.85 cm tall\r\n```\r\n\r\nYou define properties via the `property` keyword followed by an identifier.\r\n\r\nTo define a static method or property, prefix the property or func keyword with the `static` keyword.\r\n\r\n```javascript\r\nclass Box {\r\n  static property count\r\n\r\n  static func foo() {\r\n    \"class method\"\r\n  }\r\n}\r\nBox.count = 0\r\n\r\nBox.foo() # => \"class method\"\r\n```\r\n\r\nTo inherit from other classes, you use the `extends` keyword.\r\n\r\n```javascript\r\nclass Foo {\r\n  func foo() {\r\n    \"foo method\"\r\n  }\r\n}\r\n\r\nclass Bar {\r\n  func bar() {\r\n    \"bar method\"\r\n  }\r\n}\r\n\r\nclass Baz extends Foo, Bar {\r\n  func baz() {\r\n    \"baz method\"\r\n  }\r\n}\r\n\r\nlet myBaz = Baz()\r\nmyBaz.foo() # => \"foo method\"\r\nmyBaz.bar() # => \"bar method\"\r\nmyBaz.baz() # => \"baz method\"\r\n```\r\n\r\nStatic properties and methods are also copied to the child classes. The values of static properties are copied by value. They are not references.\r\n\r\n```javascript\r\nclass Foo {\r\n  static property foo\r\n\r\n  static func what() {\r\n    \"static what\"\r\n  }\r\n}\r\nFoo.foo = \"test\"\r\n\r\nclass Bar extends Foo {}\r\n\r\nBar.what() # => \"static what\"\r\nBar.foo # => \"test\"\r\n\r\nFoo.foo = \"hello world\"\r\n\r\nBar.foo # => \"test\"\r\n```\r\n\r\n## self reference\r\n\r\n`@test` will be rewritten to `self.test` by the parser automatically.\r\n\r\nThe `self` reference always points to the object a method was called on.\r\n\r\n```javascript\r\nlet myBox = {\r\n  let name;\r\n\r\n  func foo() {\r\n    @name\r\n  }\r\n}\r\n\r\nmyBox.name = \"box\"\r\nmyBox.foo() # => \"box\"\r\n```\r\n\r\nIf you directly call a method `foo()`, `self` is set to whatever it what in the context where the method is defined. Think of it like Arrow Funtions in JavaScript.\r\n\r\n```javascript\r\nlet Box = {\r\n  let name = \"box\"\r\n\r\n  func foo() {\r\n    return func() {\r\n      print(self.name)\r\n    }\r\n  }\r\n}\r\n\r\nlet method = Box.foo()\r\nmethod() # => \"box\"\r\n```\r\n\r\n## Assignments\r\n\r\nAssignment is done with the `=` character.\r\n\r\n```javascript\r\n# assigns to a local variable\r\nlocal = 1\r\n\r\n# assigns to the current self variable\r\n@instance = 2\r\n\r\n# The above is simply rewritten to\r\nself.instance = 2\r\n```\r\n\r\n## Control expressions\r\n\r\nAll control expressions inside charly behave as if they were normal expressions.\r\n\r\nThis means that altough you can't place a control expression inside a method call, it will still return a value.\r\n\r\n```javascript\r\nfunc foo(arg) {\r\n  if arg < 25 {\r\n    true\r\n  } else {\r\n    false\r\n  }\r\n}\r\n\r\nfoo(10) # => true\r\nfoo(40) # => false\r\n```\r\n\r\n### Truthy and falsey values\r\n\r\nA _truthy_ value is a value that is considered true for an `if` and `while` guard. A _falsey_ value is a value that is considered false in those places.\r\n\r\nThe only falsey values are `false` and `null`. Any other value is _truthy_.\r\n\r\n### if statements\r\n\r\nThe parenthesis around the test expression are optional\r\n\r\n```javascript\r\nif (2 < 5) {\r\n  print(\"Mathematics still works!\")\r\n} else {\r\n  print(\"Something's off...\")\r\n}\r\n\r\nif 2 + 2 == 9 - 7 {\r\n  print(\"Mathematics still works!\")\r\n} else {\r\n  print(\"Somethings's off...\")\r\n}\r\n```\r\n\r\n### while statements\r\n\r\nThe parenthesis around the test expression are optional\r\n\r\n```javascript\r\nwhile true {\r\n  print(\"and another one\")\r\n}\r\n\r\nlet i = 0\r\nwhile i < 100 {\r\n  print(i)\r\n  i += 1\r\n}\r\n```\r\n\r\nFor simple loops that repeat for a fixed amount of time, you are encouraged to use the `Numeric#times` method.\r\n\r\n```javascript\r\n5.times(->(i){\r\n  print(i)\r\n})\r\n```\r\n\r\nYou can break inside a while statement.\r\n\r\n```javascript\r\nlet i = 0\r\nwhile true {\r\n\r\n  if i >= 100 {\r\n    break\r\n  }\r\n\r\n  print(i)\r\n\r\n  i += 1\r\n}\r\n```\r\n\r\n## Types and methods\r\n\r\nThe next sections will assume you know what object oriented programming is, as well as the concepts of classes and methods.\r\n\r\n### Everything is an object\r\n\r\nEverything in Charly is an object. Not every type can have an internal state however. Only `Object`, `Class`, `PrimitiveClass` and `Array` can have an internal state.\r\n\r\nWhen you write `5`, the interpreter actually treats it as a primitive. There are no funny castings or object instantiations (inside charly). All values inside charly are boxed in heap memory. When you write `5.times`, the interpreter searches for a primitive class called `Numeric` and checks if it contains a method called `times`.\r\n\r\nThis allows the interpreter to reuse the same object for all primitives of the same type.\r\n\r\nThis principle applies to all language primitives. The primitive class `Array` for example, specified a method called `push` which inserts an element into the array.\r\n\r\n### Method arguments\r\n\r\nIf a method expects to be called with 2 arguments, you have to pass two. If you pass 1 it throws an exception.\r\n\r\n```javascript\r\nfunc foo(a, b, c) {\r\n  return true\r\n}\r\n\r\nfoo(1, 2, 3) # => true\r\nfoo(1, 2, 3, 4) # => true\r\nfoo(1, 2) # => runtime exception\r\n```\r\n\r\n### Operators\r\n\r\nYou can override any operator inside an object. Just define a method with the name set to a specific operator\r\n\r\n```javascript\r\nclass Vector2 {\r\n  property x\r\n  property y\r\n\r\n  func constructor(x, y) {\r\n    @x = x\r\n    @y = y\r\n  }\r\n\r\n  # Override plus operator\r\n  func +(other) {\r\n    Vector2(@x + other.x, @y + other.y)\r\n  }\r\n\r\n  # Override minus operator\r\n  func -(other) {\r\n    Vector2(@x - other.x, @y - other.y)\r\n  }\r\n\r\n  # Override unary minus operator\r\n  func -@() {\r\n    Vector2(-@x, -@y)\r\n  }\r\n}\r\n\r\nconst v1 = Vector2(1, 2)\r\nconst v2 = Vector2(3, 4)\r\nv1 + v2 # => Vector2(@x=4, @y=6)\r\nv1 - v2 # => Vector2(@x=-2, @y=-2)\r\n-v1 # => Vector2(@x=-1, @y=-2)\r\n```\r\n\r\nUnder the hood, the operators in the method definitions get swapped out with an identifier.\r\n\r\nThis is the mapping table:\r\n\r\n| Operator | Method name    |\r\n|----------|----------------|\r\n| +        | __plus         |\r\n| -        | __minus        |\r\n| *        | __mult         |\r\n| /        | __divd         |\r\n| %        | __mod          |\r\n| **       | __pow          |\r\n| <        | __less         |\r\n| >        | __greater      |\r\n| <=       | __lessequal    |\r\n| >=       | __greaterequal |\r\n| ==       | __equal        |\r\n| !        | __not          |\r\n| -@       | __uminus       |\r\n| +@       | __uplus        |\r\n| !@       | __unot         |\r\n\r\n## Exceptions\r\n\r\nYou can throw exceptions from anywhere in the program. Everything is throwable.\r\n\r\n```javascript\r\nfunc foo(arg) {\r\n  if arg < 10 {\r\n    throw Exception(\"arg is smaller than 10\")\r\n  }\r\n}\r\n\r\nfoo(5)\r\n```\r\n\r\nThis will show up in the console as:\r\n\r\n```\r\ntest/debug.ch\r\n      1. func foo(arg) {\r\n      2.   if arg < 10 {\r\n->    3.     throw Exception(\"arg is smaller than 10\")\r\n      4.   }\r\n      5. }\r\nat debug.ch:3:5:5\r\nat foo (debug.ch:7:1:3)\r\nUncaught Object:Exception: arg is smaller than 10\r\n```\r\n\r\n## Requiring files\r\n\r\nYou can include other files using the `require` method. It accepts a single string argument that serves as the filename.\r\n\r\nWhen including a file, the contents of the `export` variable is then returned by the `require` call.\r\n\r\nExample:\r\n\r\n__main.ch__\r\n```javascript\r\nlet external = require(\"./external.ch\")\r\nprint(external.message) # \"hello world\"\r\nprint(external.foo(1, 2)) # 3\r\n```\r\n\r\n__external.ch__\r\n```javascript\r\nexport = {\r\n  let message = \"hello world\"\r\n\r\n  func foo(l, r) {\r\n    l + r\r\n  }\r\n}\r\n```\r\n\r\nIf you call require on the same file twice, it will result the value returned by the very first call.\r\n\r\n__main.ch__\r\n```javascript\r\nlet external = require(\"./external.ch\")\r\nexternal.message = \"it changed\"\r\n\r\nlet external_second = require(\"./external.ch\")\r\nprint(external_second.message) # => \"it changed\"\r\n\r\nexternal == external_second # => true\r\n```\r\n\r\n__external.ch__\r\n```javascript\r\nexport = {\r\n  let message = \"hello world\"\r\n}\r\n```\r\n\r\nRecursive `require` call won't be catched or prevented in any way.\r\n\r\n## Command line arguments and flags\r\n\r\nThe `charly` command has the ability to receive flags. A list of these can be obtained by running `charly -h` in the command line.\r\n\r\nYou can pass flags via the following format\r\n\r\n```bash\r\ncharly input.ch -f lint\r\n```\r\n\r\nArguments which are not flags are passed to the program instead of the interpreter.\r\n\r\n```bash\r\ncharly input.ch hello -f tokens world 25 25 --foo -b\r\n                ^     ^  ^      ^     ^  ^  ^     ^\r\n                |     |__|      |_____|__|__|_____|\r\n               ARGV     |                |\r\n                      IFLAGS            ARGV\r\n```\r\n\r\nYou can access command line arguments and flags via the `ARGV` and `IFLAGS` constants. Current environment variables are available via `ENV`.\r\n\r\n```bash\r\ncharly input.ch hello -f tokens world 25 25 --foo -b\r\n```\r\n\r\n```javascript\r\nARGV # => [\"hello\", \"world\", 25, 25, \"--foo\", \"-b\"]\r\nIFLAGS # => [\"tokens\"]\r\nENV[\"TERM\"] # => xterm-256color\r\n```\r\n\r\nYou can see the license and a list of contributors via the following commands\r\n\r\n```\r\n$ charly --license\r\nThe MIT License (MIT)\r\n\r\nCopyright (c) 2016 Leonard Schuetz\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n```\r\n\r\n```\r\n# Contributors\r\n- [Leonard Schütz (Author) @KCreate](https://github.com/KCreate)\r\n- ...\r\n```\r\n\r\n## Built-in REPL\r\n\r\nCharly has a built-in REPL (Read Eval Print Loop) where you can quickly test out new ideas.\r\n\r\nYou can invoke it by typing `charly` or `charly repl`\r\n\r\nHere you can write charly statements. Run them by pressing enter.\r\n\r\nThe REPL provides a few `magic` variables which are specific to your current REPL session.\r\n\r\n- `$` This variable always contains the value of the last evaluated expression\r\n- `history` This is an array of all commands you have entered\r\n- `context` This is the top-level context of the REPL.\r\n\r\n## Extending primitive types\r\n\r\nPrimitives in Charly can be extended as if they were regular objects. A good example of this is the `Numeric#times` method. It allows you to write really expressive code like this:\r\n\r\n```javascript\r\n5.times(->{\r\n  print(\"Hello!\")\r\n})\r\n```\r\n\r\nIt is implemented like this:\r\n\r\n```javascript\r\nNumeric.methods.times = func(callback) {\r\n  let i = 0\r\n  while (i < self) {\r\n    callback(i)\r\n    i += 1\r\n  }\r\n\r\n  self\r\n}\r\n```\r\n\r\nYou can add your own methods to primitive classes via the `Numeric.methods` object.\r\n\r\nFor arrays you would use `Array.methods`, for strings `String.methods` and so on.\r\n\r\nLet's define a `indent` method on strings which takes two arguments, the amount and a filler string.\r\n\r\n```javascript\r\nString.methods.indent = ->(amount, filler) {\r\n  @split(\"\\n\").map(->(line) {\r\n    (value * amount) + line\r\n  }).join(\"\\n\")\r\n}\r\n```\r\n\r\nYou can now indent strings via the `String#indent` method.\r\n\r\n```javascript\r\n\"hello\\nworld\\nwhats\\nup\".indent(2, \"-\")\r\n\r\n# --hello\r\n# --world\r\n# --whats\r\n# --up\r\n```\r\n\r\n## Unit-testing\r\n\r\nCharly provides a built-in unit-testing library.\r\n\r\n```javascript\r\nconst UnitTest = require(\"unit-test\")\r\nconst result = UnitTest(\"myTests\").begin(->(describe) {\r\n\r\n  describe(\"some behaviour\", ->(it) {\r\n\r\n    it(\"should do something\", ->(assert) {\r\n      assert(25 + 25, 50)\r\n      assert(true, true)\r\n      assert(\"hello\", \"hello\")\r\n    })\r\n\r\n    it(\"does something else\", ->(assert) {\r\n      assert(true, false)\r\n    })\r\n\r\n  })\r\n\r\n})\r\n```\r\n\r\nRunning this file will output the following:\r\n\r\n![unit-test sample screenshot](images/unit-test.png)\r\n\r\nIf you have a lot of test cases, you can put them into another file and require them.\r\n\r\n__main.ch__\r\n```javascript\r\nconst UnitTest = require(\"unit-test\")\r\nconst result = UnitTest(\"myTests\").begin(->(describe) {\r\n\r\n  describe(\"some behaviour\", require(\"./mytest.ch\"))\r\n\r\n})\r\n```\r\n\r\n__mytest.ch__\r\n```javascript\r\nexport = ->(it) {\r\n\r\n  it(\"should do something\", ->(assert) {\r\n    assert(25 + 25, 50)\r\n    assert(true, true)\r\n    assert(\"hello\", \"hello\")\r\n  })\r\n\r\n  it(\"does something else\", ->(assert) {\r\n    assert(true, false)\r\n  })\r\n\r\n}\r\n```\r\n\r\n## IO\r\n\r\nCharly currently has bindings to STDOUT, STDERR and STDIN. Everything IO related will be found inside the `io` global object.\r\n\r\n```javascript\r\n\r\n# Using the IO object\r\nio.stdout.print(\"hello world\") # same as puts in ruby\r\nio.stdout.write(\"hello world\") # same as print in ruby\r\n\r\nio.stderr.print(\"hello world\")\r\nio.stderr.write(\"hello world\")\r\n\r\nio.stdin.gets(\"> \", false) # uses the GNU ReadLine library to read a line from STDIN\r\nio.stdin.getc() # Read a single char from STDIN\r\n\r\nio.sleep(200) # sleep for 200 miliseconds\r\n\r\nio.exit(1) # exit the program with status code 1\r\n\r\nio.stackdump() # returns the current scope in a nicely formated table\r\n\r\nio.time_ms() # returns the current unix timestamp in miliseconds\r\n\r\nio.eval(\"2 + 2\", self) # Execute \"2 + 2\", using self as the context. This call will return 4\r\n\r\n# The prelude contains direct bindings for the following methods:\r\nprint()\r\nwrite()\r\ngets()\r\ngetc()\r\nexit()\r\n```\r\n\r\n## Native extensions written in Crystal\r\n\r\nCharly currently has rudimentary support for native extensions written in Crystal.\r\n\r\nThe way this works is via Crystal files that have to be compiled into the interpreter itself.\r\n\r\nYou can add your own files like this:\r\n\r\n1. Create a file called `myfile.cr` inside `src/charly/interpreter/internals`\r\n\r\n2. Insert the following code:\r\n\r\n```crystal\r\nrequire \"../**\"\r\n\r\nmodule Chalry::Internals\r\n\r\n  charly_api \"mymethod\", myarg : TString do\r\n    return TString.new(\"You said: \" + myarg.value)\r\n  end\r\n\r\nend\r\n```\r\n\r\n3. Recompile & reinstall the interpreter\r\n\r\n4. Link against the method inside your charly program like this:\r\n\r\n```javascript\r\nconst mymethod = __internal__method(\"mymethod\")\r\n\r\nprint(mymethod(\"Hello World\")) # => You said: Hello World\r\n```\r\n\r\n5. Finished!\r\n\r\n___\r\n\r\n__Copyright © 2016 - present Leonard Schütz__\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}