{
  "name": "Charly-lang",
  "tagline": "🐈 The Charly Interpreter",
  "body": "# Charly Language Guide\r\n## Version 0.0.1\r\n\r\nYour syntax files need to be encoded in UTF-8.\r\n\r\n## Comments\r\nComments start with the sharp `#` character. Only one-line comments are currently supported.\r\n\r\n```javascript\r\n# This is a comment\r\n```\r\n\r\n## Variables\r\n\r\nVariables are defined via the `let` keyword. If you try to access a variable that wasn't initialized before, a runtime exception is thrown.\r\n\r\n```javascript\r\nlet myVar = 25\r\nlet myOtherVariable = 50\r\n\r\nmyVar + myOtherVariable # 75\r\n```\r\n\r\n## Constants\r\n\r\nConstants are declared the same way as variables. They can't be changed, hence the name constant. You need to initialize them in the declaration.\r\n\r\n```javascript\r\nconst myconst # syntax error\r\nconst myOtherConst = 25\r\nmyOtherConst = 30 # runtime exception\r\n```\r\n\r\n## Literals\r\n\r\nCharly has a total of 10 primitive types. Not all can be constructed directly. For example the `TInternalFunction` can only be gathered from a call to `__internal__method`\r\n\r\n### Null\r\nThe `Null` type can be compared to `undefined` in javascript or `nil` in some other languages.\r\n\r\n```javascript\r\nnull\r\n```\r\n\r\n### Boolean\r\nA `Boolean` only has two different values: `true` and `false`.\r\n\r\n```javascript\r\ntrue\r\nfalse\r\n```\r\n\r\n### Numeric\r\nAll Numeric types inside Charly are Crystal's native `Float64` type.\r\n\r\nNumeric literals, just like any other expression in the language, can be prefixed with `-` to negate them.\r\n\r\nUnderscores can be used to make some numbers more readable:\r\n\r\n```javascript\r\n1_000_000 # better than 1000000\r\n```\r\n\r\nFloats are created using the `.` character.\r\n\r\n```javascript\r\n123_456.456_789\r\n```\r\n\r\nA Numeric will silently overflow if you pass the lower or upper limit of `Float64`. The following REPL session elaborates this:\r\n\r\n![Numeric literal overflowing](images/overflow.png)\r\n\r\nOperations such as `1 / 0` will result in the `NAN` value.\r\n\r\n### String\r\nA String represents an immutable sequence of UTF-8 characters.\r\n\r\nIt uses Crystal's native `String` type underneath.\r\n\r\nYou can create it using `\"` characters.\r\n\r\n```javascript\r\n\"hello world\"\r\n```\r\n\r\nA backslash can be used to denote various special characters inside the string:\r\n\r\n```javascript\r\n\"\\\"\" # double quote\r\n\"\\\\\" # backslash\r\n\"\\e\" # escape\r\n\"\\f\" # form feed\r\n\"\\n\" # newline\r\n\"\\r\" # carriage return\r\n\"\\t\" # tab\r\n\"\\v\" # vertical tab\r\n```\r\n\r\nA string can span multiple lines:\r\n\r\n```javascript\r\n\"hello\r\n      word\" # same as \"hello\\n     world\"\r\n```\r\n\r\n### Array\r\nAn Array is a resizeable list of items of any type. It is typically created with an array literal:\r\n\r\n```javascript\r\n[1, 2, 3]\r\n[1, \"hello world\", [\"whats up\"]]\r\n```\r\n\r\nYou can add new items to an array using the push method:\r\n\r\n```javascript\r\nlet nums = []\r\nnums.push(0)\r\nnums.push(1)\r\nnums.push(2)\r\n\r\nnums # [0, 1, 2]\r\n```\r\n\r\nYou can concat two arrays together via the `+` operator:\r\n\r\n```javascript\r\n[1, 2] + [3, 4] # [1, 2, 3, 4]\r\n```\r\n\r\nYou can compare two arrays using the `==` operator:\r\n\r\n```javascript\r\n[1, 2, 3, 4] == [1, 2, 3, 4] # true\r\n[1, 2] == [3, 4] # false\r\n```\r\n\r\n### Objects\r\n\r\nCharly doesn't have special syntax to create objects. Instead it uses something we call `Containers`.\r\n\r\nA `Container` is basically the scope of a block turned into an Object:\r\n\r\n```javascript\r\nlet Box = {\r\n  let name = \"charly\"\r\n  let age = 200\r\n}\r\n\r\nBox.name # \"charly\"\r\nBox.age # 200\r\n```\r\n\r\nThis can be compared to the javascript equivalent of using `new Function()`:\r\n\r\n```javascript\r\nlet Box = (new function() {\r\n  this.name = \"charly\"\r\n  this.age = 200\r\n})\r\n\r\nBox.name // \"charly\"\r\nBox.age // 200\r\n```\r\n\r\nYou can access properties of objects via `[]`:\r\n\r\n```javascript\r\nlet Box = {\r\n  let name = \"mybox\"\r\n}\r\n\r\nBox[\"name\"] # \"mybox\"\r\n```\r\n\r\n### Functions\r\n\r\nYou can define a new function like this:\r\n\r\n```javascript\r\nfunc foo() {\r\n  return \"hello world\"\r\n}\r\n```\r\n\r\nWhen written inside a block as a top-level-expression, it is automatically rewritten to the following:\r\n\r\n```javascript\r\nlet foo = func() {\r\n  return \"hello world\"\r\n}\r\n```\r\n\r\nThe last expression inside a function is used as it's return value\r\n\r\n```javascript\r\nfunc foo() {\r\n  25\r\n}\r\n\r\nfoo() # 25\r\n```\r\n\r\nYou can also do explicit returns\r\n\r\n```javascript\r\nfunc foo() {\r\n  if true {\r\n    return true\r\n  }\r\n\r\n  return false\r\n}\r\n\r\nfoo() # true\r\n```\r\n\r\nIf you only need the function literal, you can use anonymous function literals:\r\n\r\n```javascript\r\nfunc foo(callback) {\r\n  callback(42)\r\n}\r\n\r\nfoo(func(arg) {\r\n  print(arg) # 42\r\n})\r\n```\r\n\r\nThere is also the lambda syntax, which goes like this:\r\n\r\n```javascript\r\n[1, 2, 3].map(->(num) {\r\n  print(num)\r\n})\r\n\r\n[1, 2, 3].map(->(num) print(num))\r\n```\r\n\r\nOf course you could also pass the print method directly, this would however result in the following:\r\n\r\n```javascript\r\n[1, 2, 3].map(print)\r\n\r\n# 1\r\n# 0\r\n# 3\r\n# 2\r\n# 1\r\n# 3\r\n# 3\r\n# 2\r\n# 3\r\n```\r\n\r\nBecause `Array#map` passes the value, index and size of the array to the callback, print will write all these values to the console.\r\n\r\nWhen you write a lambda function without parenthesis or curly braces, it will wrap the expression inside a block.\r\n\r\nThe following:\r\n\r\n```javascript\r\nfoo(->25)\r\n```\r\n\r\nbecomes:\r\n\r\n```javascript\r\nfoo(->{ 25 })\r\n```\r\n\r\nwhich in turn get's converted to:\r\n\r\n```javascript\r\nfoo(func() {\r\n  return 25\r\n})\r\n```\r\n\r\n### Classes\r\n\r\nClasses in Charly can inherit from multiple other classes.\r\n\r\nThey can have instance methods and properties and also static methods and properties.\r\n\r\nBelow is an example of a simple `Person` class.\r\n\r\n```javascript\r\nclass Person {\r\n  property name\r\n  property age\r\n  property height\r\n\r\n  func constructor(name, age, height) {\r\n    @name = name\r\n    @age = age\r\n    @height = height\r\n  }\r\n\r\n  func greet() {\r\n    print(\"My name is \" + @name)\r\n    print(\"I am \" + @age + \" years old\")\r\n    print(\"I am \" + @height + \" cm tall\")\r\n  }\r\n}\r\n\r\nlet John = Person(\"John\", 21, 1.85)\r\nJohn.greet()\r\n\r\n# Will print\r\n#\r\n# My name is John\r\n# I am 21 years old\r\n# I am 1.85 cm tall\r\n```\r\n\r\nYou define properties via the `property` keyword followed by an identifier.\r\n\r\nTo define a static method or property, prefix the property or func keyword with the `static` keyword.\r\n\r\n```javascript\r\nclass Box {\r\n  static property count\r\n\r\n  static func foo() {\r\n    \"class method\"\r\n  }\r\n}\r\nBox.count = 0\r\n\r\nBox.foo() # \"class method\"\r\n```\r\n\r\nTo inherit from other classes, you use the `extends` keyword.\r\n\r\n```javascript\r\nclass Foo {\r\n  func foo() {\r\n    \"foo method\"\r\n  }\r\n}\r\n\r\nclass Bar {\r\n  func bar() {\r\n    \"bar method\"\r\n  }\r\n}\r\n\r\nclass Baz extends Foo, Bar {\r\n  func baz() {\r\n    \"baz method\"\r\n  }\r\n}\r\n\r\nlet myBaz = Baz()\r\nmyBaz.foo() # \"foo method\"\r\nmyBaz.bar() # \"bar method\"\r\nmyBaz.baz() # \"baz method\"\r\n```\r\n\r\nStatic properties and methods are also copied to the child classes. The values of static properties are copied by value. They are not references.\r\n\r\n```javascript\r\nclass Foo {\r\n  static property foo\r\n\r\n  static func what() {\r\n    \"static what\"\r\n  }\r\n}\r\nFoo.foo = \"test\"\r\n\r\nclass Bar extends Foo {}\r\n\r\nBar.what() # \"static what\"\r\nBar.foo # \"test\"\r\n\r\nFoo.foo = \"hello world\"\r\n\r\nBar.foo # \"test\"\r\n```\r\n\r\n## `self` reference\r\n\r\n`@test` will be rewritten to `self.test` by the parser automatically.\r\n\r\nThe `self` reference always points to the object a method was called on.\r\n\r\n```javascript\r\nlet myBox = {\r\n  let name;\r\n\r\n  func foo() {\r\n    @name\r\n  }\r\n}\r\n\r\nmyBox.name = \"box\"\r\nmyBox.foo() # \"box\"\r\n```\r\n\r\nIf you directly call a method (`foo()`), `self` is set to whatever it what in the context where the method is defined. Think of it like Arrow Funtions in JavaScript.\r\n\r\n```javascript\r\nlet Box = {\r\n  let name = \"box\"\r\n\r\n  func foo() {\r\n    return func() {\r\n      print(self.name)\r\n    }\r\n  }\r\n}\r\n\r\nlet method = Box.foo()\r\nmethod() # \"box\"\r\n```\r\n\r\n## Assignments\r\n\r\nAssignment is done with the `=` character.\r\n\r\n```javascript\r\n# assigns to a local variable\r\nlocal = 1\r\n\r\n# assigns to the current self variable\r\n@instance = 2\r\n\r\n# The above is simply rewritten to\r\nself.instance = 2\r\n```\r\n\r\n## Control expressions\r\n\r\nAll control expressions inside charly behave as if they were normal expressions.\r\n\r\n```javascript\r\n\r\n```\r\n\r\n### Truthy and falsey values\r\n\r\nA _truthy_ value is a value that is considered true for an `if` and `while` guard. A _falsey_ value is a value that is considered false in those places.\r\n\r\nThe only falsey values are `false` and `null`. Any other value is _truthy_.\r\n\r\n### if statements\r\n\r\nThe parenthesis around the test expression are optional\r\n\r\n```javascript\r\nif (2 < 5) {\r\n  print(\"Mathematics still works!\")\r\n} else {\r\n  print(\"Something's off...\")\r\n}\r\n\r\nif 2 + 2 == 9 - 7 {\r\n  print(\"Mathematics still works!\")\r\n} else {\r\n  print(\"Somethings's off...\")\r\n}\r\n```\r\n\r\n### while statements\r\n\r\nThe parenthesis around the test expression are optional\r\n\r\n```javascript\r\nwhile true {\r\n  print(\"and another one\")\r\n}\r\n\r\nlet i = 0\r\nwhile i < 100 {\r\n  print(i)\r\n  i += 1\r\n}\r\n```\r\n\r\nFor simple loops that repeat for a fixed amount of time, you are encouraged to use the `Numeric#times` method.\r\n\r\n```javascript\r\n5.times(->(i){\r\n  print(i)\r\n})\r\n```\r\n\r\nYou can break inside a while statement.\r\n\r\n```javascript\r\nlet i = 0\r\nwhile true {\r\n\r\n  if i >= 100 {\r\n    break\r\n  }\r\n\r\n  print(i)\r\n\r\n  i += 1\r\n}\r\n```\r\n\r\n## Types and methods\r\n\r\nThe next sections will assume you know what object oriented programming is, as well as the concepts of classes and methods.\r\n\r\n### Everything is an object\r\n\r\nEverything in Charly is an object. Not every type can have an internal state however. Only `Object`, `Class`, `PrimitiveClass` and `Array` can have an internal state.\r\n\r\nWhen you write `5`, the interpreter actually treats it as a primitive. There are no funny castings or object instantiations (inside charly). All values inside charly are boxed in heap memory. When you write `5.times`, the interpreter searches for a primitive class called `Numeric` and checks if it contains a method called `times`.\r\n\r\nThis allows the interpreter to reuse the same object for all primitives of the same type.\r\n\r\nThis principle applies to all language primitives. The primitive class `Array` for example, specified a method called `push` which inserts an element into the array.\r\n\r\n### Method arguments\r\n\r\nIf a method expects to be called with 2 arguments, you have to pass two. If you pass 1 it throws an exception.\r\n\r\n```javascript\r\nfunc foo(a, b, c) {\r\n\r\n}\r\n\r\nfoo(1, 2, 3) # okay\r\nfoo(1, 2, 3, 4) # also okay\r\nfoo(1, 2) # \r\n```\r\n\r\n### Operators\r\n\r\nYou can override any operator inside an object. Just define a method with the corresponding name.\r\n\r\n```javascript\r\nclass Vector2 {\r\n  property x\r\n  property y\r\n\r\n  func constructor(x, y) {\r\n    @x = x\r\n    @y = y\r\n  }\r\n\r\n  func __plus(other) {\r\n    Vector2.new(@x + other.x, @y + other.y)\r\n  }\r\n}\r\n\r\nv1 = Vector2(1, 2)\r\nv2 = Vector2(3, 4)\r\nv1 + v2 # Vector2(@x=4, @y=6)\r\n```\r\n\r\nOverrideable operators are:\r\n\r\n- `+` = `__plus`\r\n- `-` = `__minus`\r\n- `*` = `__mult`\r\n- `/` = `__divd`\r\n- `%` = `__mod`\r\n- `**` = `__pow`\r\n\r\n- `!` = `__unot`\r\n- `-` = `__uminus`\r\n\r\n- `<` = `__less`\r\n- `>` = `__greater`\r\n- `<=` = `__lessequal`\r\n- `>=` = `__greaterequal`\r\n- `==` = `__equal`\r\n- `!` = `__not`\r\n\r\n## Exceptions\r\n\r\nYou can throw exceptions from anywhere in the program. Everything is throwable.\r\n\r\n```javascript\r\nfunc foo(arg) {\r\n  if arg < 10 {\r\n    throw Exception(\"arg is smaller than 10\")\r\n  }\r\n}\r\n\r\nfoo(5)\r\n```\r\n\r\nThis will show up in the console as:\r\n\r\n```\r\ntest/debug.ch\r\n      1. func foo(arg) {\r\n      2.   if arg < 10 {\r\n->    3.     throw Exception(\"arg is smaller than 10\")\r\n      4.   }\r\n      5. }\r\nat debug.ch:3:5:5\r\nat foo (debug.ch:7:1:3)\r\n\r\nUncaught Object:Exception: arg is smaller than 10\r\n```\r\n\r\n## Requiring files\r\n\r\nYou can include other files using the `require` method. It accepts a single string argument that serves as the filename.\r\n\r\nWhen including a file, the contents of the `export` variable is then returned by the `require` call.\r\n\r\nExample:\r\n\r\n__main.ch__\r\n```javascript\r\nlet external = require(\"./external.ch\")\r\nprint(external.message) # \"hello world\"\r\nprint(external.foo(1, 2)) # 3\r\n```\r\n\r\n__external.ch__\r\n```javascript\r\nexport = {\r\n  let message = \"hello world\"\r\n\r\n  func foo(l, r) {\r\n    l + r\r\n  }\r\n}\r\n```\r\n\r\nIf you call require on the same file twice, it will result the value returned by the very first call.\r\n\r\n__main.ch__\r\n```javascript\r\nlet external = require(\"./external.ch\")\r\nexternal.message = \"it changed\"\r\n\r\nlet external_second = require(\"./external.ch\")\r\nprint(external_second.message) # \"it changed\"\r\n\r\nexternal == external_second # true\r\n```\r\n\r\n__external.ch__\r\n```javascript\r\nexport = {\r\n  let message = \"hello world\"\r\n}\r\n```\r\n\r\nRecursive `require` call won't be catched or prevented in any way.\r\n\r\n## Command line arguments and flags\r\n\r\nThe `charly` command has the ability to receive flags. A list of these can be obtained by running `charly -h` in the command line.\r\n\r\nYou can pass flags via the following format\r\n\r\n```bash\r\ncharly input.ch -f lint\r\n```\r\n\r\nArguments which are not flags are passed to the program instead of the interpreter.\r\n\r\n```bash\r\ncharly input.ch hello -f tokens world 25 25 --foo -b\r\n                ^     ^  ^      ^     ^  ^  ^     ^\r\n                |     |__|      |_____|__|__|_____|\r\n               ARGV     |                |\r\n                      IFLAGS            ARGV\r\n```\r\n\r\nYou can access command line arguments and flags via the `ARGV` and `IFLAGS` constants. Current environment variables are available via `ENV`.\r\n\r\n```bash\r\ncharly input.ch hello -f tokens world 25 25 --foo -b\r\n```\r\n\r\n```javascript\r\nARGV # [\"hello\", \"world\", 25, 25, \"--foo\", \"-b\"]\r\nIFLAGS # [\"tokens\"]\r\nENV[\"TERM\"] # xterm-256color\r\n```\r\n\r\n## Extending primitive types\r\n\r\nPrimitives in Charly can be extended as if they were regular objects. A good example of this is the `Numeric#times` method. It allows you to write really expressive code like this:\r\n\r\n```javascript\r\n5.times(->{\r\n  print(\"Hello!\")\r\n})\r\n```\r\n\r\nIt is implemented like this:\r\n\r\n```javascript\r\nNumeric.methods.times = func(callback) {\r\n  let i = 0\r\n  while (i < self) {\r\n    callback(i)\r\n    i += 1\r\n  }\r\n\r\n  self\r\n}\r\n```\r\n\r\nYou can add your own methods to primitive classes via the `Numeric.methods` object.\r\n\r\nFor arrays you would use `Array.methods`, for strings `String.methods` and so on.\r\n\r\nLet's define a `indent` method on strings which takes two arguments, the amount and a filler string.\r\n\r\n```javascript\r\nString.methods.indent = ->(amount, filler) {\r\n  @split(\"\\n\").map(->(line) {\r\n    (value * amount) + line\r\n  }).join(\"\\n\")\r\n}\r\n```\r\n\r\nYou can now indent strings via the `String#indent` method.\r\n\r\n```javascript\r\n\"hello\\nworld\\nwhats\\nup\".indent(2, \"-\")\r\n\r\n# --hello\r\n# --world\r\n# --whats\r\n# --up\r\n```\r\n\r\n## Unit-testing\r\n\r\nCharly provides a built-in unit-testing library.\r\n\r\n```javascript\r\nconst UnitTest = require(\"unit-test\")\r\nconst result = UnitTest(\"myTests\").begin(->(describe) {\r\n\r\n  describe(\"some behaviour\", ->(it) {\r\n\r\n    it(\"should do something\", ->(assert) {\r\n      assert(25 + 25, 50)\r\n      assert(true, true)\r\n      assert(\"hello\", \"hello\")\r\n    })\r\n\r\n    it(\"does something else\", ->(assert) {\r\n      assert(true, false)\r\n    })\r\n\r\n  })\r\n\r\n})\r\n```\r\n\r\nRunning this file will output the following:\r\n\r\n![unit-test sample screenshot](images/unit-test.png)\r\n\r\nIf you have a lot of test cases, you can put them into another file and require them.\r\n\r\n__main.ch__\r\n```javascript\r\nconst UnitTest = require(\"unit-test\")\r\nconst result = UnitTest(\"myTests\").begin(->(describe) {\r\n\r\n  describe(\"some behaviour\", require(\"./mytest.ch\"))\r\n\r\n})\r\n```\r\n\r\n__mytest.ch__\r\n```javascript\r\nexport = ->(it) {\r\n\r\n  it(\"should do something\", ->(assert) {\r\n    assert(25 + 25, 50)\r\n    assert(true, true)\r\n    assert(\"hello\", \"hello\")\r\n  })\r\n\r\n  it(\"does something else\", ->(assert) {\r\n    assert(true, false)\r\n  })\r\n\r\n}\r\n```\r\n\r\n___\r\n\r\n__Copyright © 2016 - present Leonard Schütz__",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}